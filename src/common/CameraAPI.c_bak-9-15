//#include "CameraAPI.h"
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include "rtmpSender.h"
#include <curl/curl.h>
#include "PusherClient.h"
#include "camera_log.h"
#include "Hash_alg.h"
#include "aes128.h"
#include "platform_cfg.h"
#include <openssl/aes.h>
#include "cJSON.h"
#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>


typedef int (*D_MessageCallBack)(void *apData, const char *aMessage);
typedef void (*D_RtmpAudioCallBack)(char* aData,int aDataLen);

int  D_HttpPostRTMPURL(char aMode);
int  D_HttpRemoveRTMPURL();

int rtmpopenflag = 0;
int s_start_cloud_flag = 0;
volatile int LY_PublicLiveFlag = 0;
static int log_flag =0;
static int retry_count =0;
volatile unsigned long long LY_AlarmStartTime =0;
platform_config_t platform_global_config;

unsigned long C_StartTime = 0;
unsigned int C_FrameRate;
unsigned long C_BitRate;

extern char RTMP_Enable_AES128;
extern unsigned int RTMP_C_FrameRate;
extern unsigned int RTMP_C_BitRate;

typedef struct rtmp_time
{
	unsigned long  Tbegain;
	unsigned long  T1;
	unsigned long  Tend;
	unsigned long  Tn_T1;
	unsigned long  Tstart_end;
	unsigned long  Tend_start;
}rtmp_time_t;

rtmp_time_t rtmp_send_time;

static void set_defalut_platform_config(platform_config_t* config)
{
    strcpy(config->rtmp_url,"rtmp://120.24.88.82/demo/999999");
    strcpy(config->rtmp_log_dir,"/media/mmcblk0p1/");
    strcpy(config->web_server_ip,"120.26.65.144");
    //strcpy(config->web_server_ip,"121.41.118.167");
    config->web_server_port = 8005;
    //config->web_server_timeout = 5;
    config->web_server_timeout = 10;
    config->cid = 0;
}

static void set_defalut_globle_value()
{
	retry_count = 0;
	C_StartTime = 0;
	C_FrameRate = 0;
	C_BitRate = 0;
	RTMP_C_FrameRate = 0;
	RTMP_C_BitRate = 0;
	LY_AlarmStartTime = 0;	
	
	rtmp_send_time.Tbegain= 0;
	rtmp_send_time.T1= 0;
	rtmp_send_time.Tend = 0;
	rtmp_send_time.Tn_T1 = 0;
	rtmp_send_time.Tstart_end = 0;
	rtmp_send_time.Tend_start = 0;
}

void D_Send_Log(const char *msg)
{
	Send_Log(msg,0x0301);
}

int Get_Device_Meminfo(char *msg)
{
//        char msg[40]={0};
        char data[30]={0};
        char key[10]={0};
        char value[10]={0};

        int i =4;
        int ret = 0;
        FILE *file;
        file = fopen("/proc/meminfo","r");
        if(file == NULL)
	{
                Send_Log("fopen meminfo failed!",0x0301);
		return -1;
	}

        while(i--)
        {
                if(fgets(data,30,file) != NULL)
                {
                        ret = sscanf(data,"%s%s[^\n]",key,value);
                        if(ret !=2){
                                memset(data,0,sizeof(data));
                                memset(key,0,sizeof(key));
                                memset(value,0,sizeof(value));
				Send_Log("fgets Mem return no data !",0x0301);
                                continue;
                        }
#if 1
                        if(strcmp(key,"MemTotal:") == 0){
                                strcat(msg,"Mt:");
                                strncat(msg,value,6);
                        }else if(strcmp(key,"MemFree:") == 0){
                                strcat(msg,",Mf:");
                                strncat(msg,value,5);
                        }else if(strcmp(key,"Buffers:") == 0){
                                strcat(msg,",Bf:");
                                strncat(msg,value,5);
                        }else if(strcmp(key,"Cached:") == 0){
                                strcat(msg,",Ch:");
                                strncat(msg,value,5);
                        }
#endif
                }
                else
                        Send_Log("fgets data==== null!",0x0301);
        }

	if(file)
	{
		fclose(file);
		file = NULL;	
	}

	return 0;
}

int Get_Allfd(int pid)
{
	DIR * pdir;
	struct dirent * pdirent;  
//	struct stat f_ftime;   
	int fcnt;/*文件数目统计*/
	char path[25]={0};
	sprintf(path,"/proc/%d/fd/",pid);  
	pdir=opendir(path);  
	if(pdir==NULL)  
	{
		strcat(path," failed!"); 
		Send_Log(path,0x0301);
		return 0; 
	} 
	fcnt=0; 
	for(pdirent=readdir(pdir);pdirent!=NULL;pdirent=readdir(pdir))
	{   
		if(strcmp(pdirent->d_name,".")==0||strcmp(pdirent->d_name,"..")==0) 
			continue; 
		//if(stat(pdirent->d_name,&f_ftime)!=0) 
		//	return 0;    
		//if(S_ISDIR(f_ftime.st_mode)) 
		//	continue; /*子目录跳过*/  
		fcnt++;  
		//printf("name:%s\n",pdirent->d_name); 
	} 
	//printf("all:%d\n",fcnt);
	closedir(pdir);  
	pdir = NULL;
	pdirent = NULL;

	return fcnt;
}


void *Msg_Handler(void *arg)
{
	sleep(70);
	log_flag = 1;
        Send_Log("start log msg_pthread success",0x0301);
	char msg[60]={0};
	char pid_fp[20];
	int pid = getpid();
	int fpcnt =0;
	while(log_flag)
	{
		fpcnt = Get_Allfd(pid);
		memset(msg,0,sizeof(msg));
		if(Get_Device_Meminfo(msg) == 0)
		{
			sprintf(pid_fp,",pid:%d,fd:%d",pid,fpcnt);
			strcat(msg,pid_fp);
			Send_Log((const char *)msg,0x0301);
		}
		sleep(60);
	}

        Send_Log("log msg_pthread exit!",0x0301);
	pthread_exit(0);
}

void Create_log_pthread(const char *SN,const int aCid)
{
    	char log[60]={0};
    	sprintf(log,"sn:%s,cid:%d,StartCloudService",SN,aCid);
    	Send_Log(log,0x0301);
	
	if(log_flag == 0)
	{
		int err;
        	pthread_t tid;
        	pthread_attr_t attr_handle;
		pthread_attr_init(&attr_handle);
        	pthread_attr_setdetachstate(&attr_handle, PTHREAD_CREATE_DETACHED);
        	err = pthread_create(&tid,&attr_handle,Msg_Handler,NULL);
        	if(err)
        	{
			memset(log,0,sizeof(log));
			sprintf("sn:%s,cid:%d,create log pthread failed",SN,aCid);
                	Send_Log(log,0x0301);
                	return;
        	}

	}
}

int  D_StartCloudService(const char *app_id, const char* aSN, const int aCid, void *apData, D_MessageCallBack apMessageCallBack)
{
    set_defalut_platform_config(&platform_global_config);
    s_start_cloud_flag = 0;
    char SN[25]={0};
    sprintf(SN,"%s%s",app_id,aSN);  
    char strconfig[500];
    memset(strconfig, 0, 500);
    sprintf(strconfig,"[Config]\r\nCID=%d\r\nSN=%s%s\r\nIsCaptureDev=1\r\nIsPlayDev=1\r\nIsSendBroadcast=0\r\nUdpSendInterval=2\r\n[Tracker]\r\nCount=3\r\nIP1=121.42.156.148\r\nPort1=80\r\nIP2=182.254.149.39\r\nPort2=80\r\nIP3=203.195.157.248\r\nPort3=80\r\n",aCid,app_id,aSN);

    int nRet = StartCloudService(strconfig, apData, apMessageCallBack);
    if(nRet == 0)
    {
	s_start_cloud_flag = 1;
	Create_log_pthread((const char *)SN,aCid);
        platform_global_config.cid = aCid;
	
    }

    return nRet;
}
    
void  D_StopCloudService()
{
    if(s_start_cloud_flag)
    {
    	Send_Log("D_StopCloudService",0x0301);
    	StopCloudService();
    }

    log_flag = 0;
    s_start_cloud_flag = 0;
}
   
int D_GetDeviceToken(char *aToken)
{
    if(NULL == aToken)
	return -1;

    char *status = GetStatus();
    cJSON *root = cJSON_Parse(status);
    cJSON *token = cJSON_GetObjectItem(root, "ToKen");
    
    int TokenLength = strlen(token->valuestring);	
    strncpy(aToken,token->valuestring,TokenLength);

    cJSON_Delete(root);

    //printf("======== token:%s , len = %d\n",aToken,TokenLength);
    return TokenLength;
}
 
char* D_GetStatus()
{
    return GetStatus();
}




static int frame_type(const char* p_data)
{
    char* pTmp = p_data;
        if((*pTmp == 0)&&(*(pTmp+1)==0)&&(*(pTmp+2)==0)&&(*(pTmp+3)==1)){
                char type = (*(pTmp+4)) & 0x1f;
	
                if(type == 7){
                        return 7;
                }else if(type == 8){
                        return 8;
                }
                else if(type == 6){
                        return 6;
                }
                else if(type == 5){
                        return 5;
                }
                else if(type == 1){
                        return 1;
                }
                else
                        return -1;
        }

        return -1;
}

char* findSPSOffset(const char* p_data,int len)
{
    int i;
    for(i=0;i<len;i++){
            char* pTmp = p_data+i;
            if(i+5 >=len)
                return NULL;

                        if(frame_type(pTmp) == 7){
                                return pTmp;
                                //return pTmp+4;
                        }
    }

    return NULL;
}

char* findPPSOffset(const char* p_data,int len)
{
    int i;
    for(i=0;i<len;i++){
            char* pTmp = p_data+i;
            if(i+5 >=len)
                return NULL;

                        if(frame_type(pTmp) == 8){
                                return pTmp;
                                //return pTmp+4;
                        }
    }

    return NULL;
}

char* findSEIOffset(const char* p_data,int len)
{
    int i;
    for(i=0;i<len;i++){
            char* pTmp = p_data+i;
            if(i+5 >=len)
                return NULL;

                        if(frame_type(pTmp) == 6){
                                return pTmp;
                                //return pTmp+4;
                        }
    }

    return NULL;
}

char* findIFrameOffset(const char* p_data,int len)
{
    int i;
    for(i=0;i<len;i++){
            char* pTmp = p_data+i;
            if(i+5 >=len)
                return NULL;

                        if(frame_type(pTmp) == 5){
                                //return pTmp+4;
                                return pTmp;
                        }
    }

    return NULL;
}


int   S_PushData(unsigned long aDataLevelPos, const char *aDataBuffer,  unsigned long  aBufferLength, unsigned long aTimestamp, unsigned char apFrameSampleType)
{
	int ret = 0;
	char type = frame_type(aDataBuffer);
	//printf(" type:%d, data src: %x,%x,%x,%x,%x,%x,%x,%x,%x,%x\n",type,*(aDataBuffer),*(aDataBuffer+1),*(aDataBuffer+2),*(aDataBuffer+3),*(aDataBuffer+4),*(aDataBuffer+5),*(aDataBuffer+6),*(aDataBuffer+7),*(aDataBuffer+8),*(aDataBuffer+9));
        if(type==7){                    //first is sps
                int spsLen;
        	int ppsLen;
        	int seiLen;
        	int iframeLen;
	
        	char* pSPS = findSPSOffset(aDataBuffer,aBufferLength);
        	char* pPPS = findPPSOffset(aDataBuffer,aBufferLength);
        	char* pIFrame = findIFrameOffset(aDataBuffer,aBufferLength);
        	int tmpLen = pIFrame-pPPS;
        	char* pSEI = findSEIOffset(pPPS,tmpLen);

        	if(pSEI){
                	spsLen = pPPS - pSPS;
                	ppsLen = pSEI - pPPS;
                	seiLen = pIFrame - pSEI;
                	iframeLen = aBufferLength - spsLen -ppsLen -seiLen;
        	}
        	else
        	{	
                        spsLen = pPPS - pSPS;
                	ppsLen = pIFrame - pPPS;
                	//ppsLen = pSEI - pPPS;
                	iframeLen = aBufferLength - spsLen -ppsLen;
        	}
		
#ifdef ENABLE_AES128
		if(pIFrame)
		{
			unsigned char* encrypt_out;
        		unsigned int encrypt_len;

			//printf("iframe: %x %x %x %x %x %x %x\n",*pIFrame,*(pIFrame+1),*(pIFrame+2),*(pIFrame+3),*(pIFrame+4),*(pIFrame+5),*(pIFrame+6));
        		int ret = D_aes_encrypt((unsigned char*)(pIFrame+1),(unsigned int)(iframeLen-1 - (iframeLen-1)%16),&encrypt_out,&encrypt_len);
			if(ret != -1)
			{
        			memcpy(pIFrame+1,encrypt_out,encrypt_len);
        			free(encrypt_out);
			}
		}
#endif
		//printf("D_aes_encrypt end .........sps:%d, pps:%d, iframe:%d\n",spsLen,ppsLen,iframeLen);
		ret = PushData(aDataLevelPos,pSPS,spsLen,aTimestamp,NALU_TYPE_SPS);//7
		ret = PushData(aDataLevelPos,pPPS,ppsLen,aTimestamp,NALU_TYPE_PPS);//8
		ret = PushData(aDataLevelPos,pIFrame,iframeLen,aTimestamp,NALU_TYPE_IDR);//5
        }
	else if(type==1){                       //p frame
                if(aBufferLength>4){
                      ret = PushData(aDataLevelPos,aDataBuffer,aBufferLength,aTimestamp,NALU_TYPE_SLICE);//1
                }
        }
	else 
	{	//else if(apFrameSampleType == NALU_TYPE_AUD)
		ret = PushData(aDataLevelPos,aDataBuffer,aBufferLength,aTimestamp,apFrameSampleType);
		//printf("send aac  ===== length:%ld, time stamp: %ld , frame type: %x , type1 :%x\n",aBufferLength,aTimestamp,apFrameSampleType,type);
	}
	return ret;
}


char* D_PopData(unsigned long aDataLevelPos, unsigned long *apFrameSampleLength, unsigned long *apTimestamp, unsigned char *apFrameSampleType)
{
    return PopData(aDataLevelPos,apFrameSampleLength,apTimestamp,apFrameSampleType);
}

int D_SetAlarmInfo(unsigned long long aAlarmTime)
{
        LY_AlarmStartTime = aAlarmTime;
        return sendGetDiskListCommand();
}

int Send_Alarm_Msg(unsigned char *buffer, int disk_size)
{
        printf("=================start=================\n");
        char msg[256];
        //int disk_size = 0;
        int ret =0;
	//cid
	msg[0] = platform_global_config.cid & 0xff;
        msg[1] = (platform_global_config.cid>>8) & 0xff;
        msg[2] = (platform_global_config.cid>>16) & 0xff;
        msg[3] = (platform_global_config.cid>>24) & 0xff;
	//alarm time
        msg[4] = LY_AlarmStartTime & 0xff;
        msg[5] = (LY_AlarmStartTime>>8) & 0xff;
        msg[6] = (LY_AlarmStartTime>>16) & 0xff;
        msg[7] = (LY_AlarmStartTime>>24) & 0xff;

        memcpy(msg+8,buffer,disk_size);

        printf("ret:%d time:%ld ,size:%d,msg0:%d\n",ret,LY_AlarmStartTime,disk_size,msg[0]);
        ret = D_PushMessage(0, msg, disk_size+8);
        printf("ret:%d \n",ret);
        printf("=================end=================\n");

        return ret;
}

void D_SetRtmpAudioCallBack(D_RtmpAudioCallBack aRtmpAudioCall)
{
        platform_global_config.rtmp_fun[0] = (char *)aRtmpAudioCall;
}

void RTMP_PopDataCall(int type,char* data,int len)
{
        printf("recv rtmp  data type:%d len:%d, %x %x %x %x \n",type,len,*data,*(data+1),*(data+2),*(data+3) );
        int i,ret = -1;
        if(type == 1)           //audio
        {
		if(platform_global_config.rtmp_fun[0] != NULL)
                	((D_RtmpAudioCallBack)platform_global_config.rtmp_fun[0])(data,len);
        }
        else if(type == 2)      //alarm
        {
                for(i=0; i<3; i++)
                {
                        ret = Send_Alarm_Msg((unsigned char *)data, len);
                        if(ret == 1)
                                break;
                        else
                                usleep(300);
                }
                LY_AlarmStartTime = 0;
        }
}

int ConnectRTMP()
{
    int ret = -1;
    if (rtmpopenflag == 0) {
		//cmsprintf("SDK:connect to rtmp server\n");
#if 1
		setDeviceType(1);
		//setLogDir(platform_global_config.rtmp_log_dir);
		//platform_global_config.rtmp_fun[0] = (char *)aRtmpAudioCall;
                ret = ConnectToRtmpServer((const char *)platform_global_config.rtmp_url,RTMP_PopDataCall,1);
		//ret = ConnectToRtmpServer((const char *)platform_global_config.rtmp_url,RTMPPopDataCallBack,1);
#else
		//setLogDir("./");
		setDeviceType(1);
    		char url[50];
    		memset(url,0,50);
    		sprintf(url,"rtmp://120.24.88.92:1935/demo/%d",platform_global_config.cid);
		//platform_global_config.rtmp_fun[0] = (char *)aRtmpAudioCall;
                ret = ConnectToRtmpServer(url,RTMP_PopDataCall,1);
		//ret = ConnectToRtmpServer(url,RTMPPopDataCallBack,1);
#endif
        rtmpopenflag = 1;
    }
    return ret;
}

void DisConnectRTMP()
{
    if (rtmpopenflag == 1) {
        rtmpopenflag = 0;
        DisconnectRtmpServer();
    }
    
}

int  D_StartRtmpServer(RTMPMetaData aMetaData)
{
    set_defalut_globle_value();
    setMetaData(aMetaData);
    return ConnectRTMP();
}
    
void  D_StopRtmpServer()
{
    DisConnectRTMP();
}


void Count_BitRate_FrameRate(unsigned long aBufferLength, unsigned char apFrameSampleType)
{
	if(apFrameSampleType == NALU_TYPE_AUD || apFrameSampleType == AAC_TYPE_INFO || apFrameSampleType == AAC_TYPE_SAMPLE)
		;
		//printf("audio frame\n");
	else
	{
		C_FrameRate++;		
	}

	C_BitRate += aBufferLength;
	
	unsigned long  subTime = 0;
        unsigned long  curTime = Sys_GetTickCount();
        if(C_StartTime == 0 || C_StartTime > curTime)
	{
                C_StartTime = curTime;
		return;
	}

        subTime = curTime - C_StartTime;
        if(subTime >= 2000)
        {
                //printf("subTime:%ld ,vframe: %d,tatol bit:%ld,kb:%d \n",subTime,C_FrameRate/2,C_BitRate/2,C_BitRate/1024/2);
                C_StartTime = curTime;
		RTMP_C_FrameRate = C_FrameRate/2;
		RTMP_C_BitRate = C_BitRate/1024/2;
		C_FrameRate = 0;
		C_BitRate = 0;
        }
}




int S_SendRTMPData(char * aDataBuffer,unsigned long aBufferLength, unsigned long aTimestamp,unsigned char apFrameSampleType)
{

    unsigned long  Tstart = 0;

    RTMP_Enable_AES128 = 0x00;
    Count_BitRate_FrameRate(aBufferLength,apFrameSampleType);

    aTimestamp = aTimestamp%0xFFFFFE;
    if(apFrameSampleType == NALU_TYPE_AUD)
    {
        SendOpus(aDataBuffer, aBufferLength,aTimestamp);
    }
    else if(apFrameSampleType == AAC_TYPE_INFO)
    {
		SendAacInfo(aDataBuffer, aBufferLength,aTimestamp);
		//printf("send aac info ===== length:%ld, time stamp: %ld\n",aBufferLength,aTimestamp);
    }
    else if(apFrameSampleType == AAC_TYPE_SAMPLE)
    {
		SendAAC(aDataBuffer, aBufferLength,aTimestamp);
		//printf("send aac sample ===== length:%ld, time stamp: %ld\n",aBufferLength,aTimestamp);
    }
    else
    {
	 	int ret = 0;
        	char type = frame_type(aDataBuffer);
        	if(type==7){                    //first is sps
			int spsLen;
                	int ppsLen;
                	int seiLen;
                	int iframeLen;

                	char* pSPS = findSPSOffset(aDataBuffer,aBufferLength);
                	char* pPPS = findPPSOffset(aDataBuffer,aBufferLength);
                	char* pIFrame = findIFrameOffset(aDataBuffer,aBufferLength);
                	int tmpLen = pIFrame-pPPS;
                	char* pSEI = findSEIOffset(pPPS,tmpLen);

                	if(pSEI){
                        	spsLen = pPPS - pSPS -4;
                        	ppsLen = pSEI - pPPS -4;
                        	seiLen = pIFrame - pSEI -4;
                        	iframeLen = aBufferLength - spsLen -ppsLen -seiLen -16;
                	}
                	else
                	{
                        	spsLen = pPPS - pSPS -4;
                		ppsLen = pIFrame - pPPS -4;
                        	//ppsLen = pSEI - pPPS -4;
                        	iframeLen = aBufferLength - spsLen -ppsLen -12;
                	}
			
#ifdef ENABLE_AES128
			if(LY_PublicLiveFlag == 0)		//is not publicLive
			{
				RTMP_Enable_AES128 = 0x01;
				if(pIFrame)
        			{
            				unsigned char* encrypt_out;
            				unsigned int encrypt_len;

        				int ret = D_aes_encrypt((unsigned char*)(pIFrame+4+1),(unsigned int)(iframeLen-1 - (iframeLen-1)%16),&encrypt_out,&encrypt_len);

        				memcpy(pIFrame+4+1,encrypt_out,encrypt_len);
            				free(encrypt_out);
				}
        		}
#endif
			Tstart = Sys_GetTickCount();
			if(rtmp_send_time.T1 == 0 || rtmp_send_time.T1 > Tstart)	
				rtmp_send_time.T1 = Tstart;
			else
				rtmp_send_time.Tend_start += (Tstart - rtmp_send_time.Tend);


			//printf("D_aes_encrypt end .........sps:%d, pps:%d, iframe:%d\n",spsLen,ppsLen,iframeLen);
			SendNal(pSPS+4,spsLen,aTimestamp);
        		SendNal(pPPS+4,ppsLen,aTimestamp);
			SendNal(pIFrame+4,iframeLen,aTimestamp);
			//printf("D_aes_encrypt end iframe:%x %x %x %x %x %x %x %x %x %x\n",*(pIFrame+4),*(pIFrame+4+1),*(pIFrame+4+2),*(pIFrame+4+3),*(pIFrame+4+4),*(pIFrame+4+5),*(pIFrame+4+6),*(pIFrame+4+7),*(pIFrame+4+8),*(pIFrame+4+9));
    		}
        	else if(type==1)
		{   
	                //p frame	
			if(aBufferLength>4)
			{
				Tstart = Sys_GetTickCount();
				if(rtmp_send_time.T1 == 0 || rtmp_send_time.T1 > Tstart)	
					rtmp_send_time.T1 = Tstart;
				else
					rtmp_send_time.Tend_start += (Tstart - rtmp_send_time.Tend);

                		SendNal(aDataBuffer+4,aBufferLength-4,aTimestamp);
                	}
        	}
		else
		{
			Tstart = Sys_GetTickCount();
			if(rtmp_send_time.T1 == 0 || rtmp_send_time.T1 > Tstart)	
				rtmp_send_time.T1 = Tstart;
			else
				rtmp_send_time.Tend_start += (Tstart - rtmp_send_time.Tend);
                	
			SendNal(aDataBuffer+4,aBufferLength-4,aTimestamp);
		}
	
        	rtmp_send_time.Tend = Sys_GetTickCount();
		//printf("tend:%ld, t1:%ld\n",Tend,T1);
		rtmp_send_time.Tn_T1 = rtmp_send_time.Tend - rtmp_send_time.T1;
		rtmp_send_time.Tstart_end += (rtmp_send_time.Tend - Tstart); 

		if(rtmp_send_time.Tbegain == 0)
		{
			rtmp_send_time.Tbegain = Tstart;
		}

		if(rtmp_send_time.Tn_T1 >= 5000)
		{
			printf(" === Tn_T1:%ld, Tsend:%ld, Tfree:%ld\n",rtmp_send_time.Tn_T1,rtmp_send_time.Tstart_end,rtmp_send_time.Tend_start);
			//send_log();
			char info[50]={0};
        		sprintf(info,"T5_T1:%ld, Tsend:%ld, Tfree:%ld",rtmp_send_time.Tn_T1,rtmp_send_time.Tstart_end,rtmp_send_time.Tend_start);
        		Send_Log((const char *)info,0x0302);
#if 0
			//if((rtmp_send_time.Tend-rtmp_send_time.Tbegain) >= )
			if((double)rtmp_send_time.Tstart_end/(double)rtmp_send_time.Tend_start >= 0.5)				
			{
				printf("========== send msg to app ==========:%lf\n",(double)rtmp_send_time.Tstart_end/(double)rtmp_send_time.Tend_start);
                                D_PushMessage(0, "12345", 5);
			}			
#endif
			rtmp_send_time.T1 = 0;
			rtmp_send_time.Tend = 0;
			rtmp_send_time.Tn_T1 = 0;
			rtmp_send_time.Tstart_end = 0;
			rtmp_send_time.Tend_start = 0;
		}

	}

	return 1;
}

unsigned char aacSeqHeader[2]={0};
static int GetAacHeadInfo(char *payload, long dataLen)
{
        int profile = ((payload[2]&0xc0)>>6)+1;
        int sample_rate = (payload[2]&0x3c)>>2;
        int channel = ((payload[2]&0x1)<<2)|((payload[3]&0xc0)>>6);
        int config1 = (profile<<3)|((sample_rate&0xe)>>1);
        int config2 = ((sample_rate&0x1)<<7)|(channel<<3);

        aacSeqHeader[0] = config1&0xFF;
        aacSeqHeader[1] = config2&0xFF;

        //printf("...profile:%d, sample_rate:%d, channel:%d, config1:%d, config2:%d,aac header1:%x,aac header2:%x\n",profile,sample_rate,channel,config1,config2,aacSeqHeader[0],aacSeqHeader[1]);
        return 0;
}


int   D_PushData(unsigned long aDataLevelPos, const char *aDataBuffer, unsigned long aBufferLength, unsigned long aTimestamp, unsigned char apFrameSampleType)
{
	int nRet = 0;
        if(rtmpopenflag == 0) //p2p
                nRet =  S_PushData(aDataLevelPos, aDataBuffer, aBufferLength, aTimestamp, apFrameSampleType);
        else            //rtmp
        {
                if(apFrameSampleType == AAC_TYPE_SAMPLE)
                {
                        GetAacHeadInfo((char *)(aDataBuffer), aBufferLength);
                        nRet = S_SendRTMPData((char *)aacSeqHeader, 2, aTimestamp, AAC_TYPE_INFO);
                        nRet = S_SendRTMPData((char *)(aDataBuffer+7), aBufferLength-7, aTimestamp, AAC_TYPE_SAMPLE);
                }
                else
                        nRet = S_SendRTMPData((char *)aDataBuffer, aBufferLength, aTimestamp, apFrameSampleType);
        }

        return nRet;
}

//int SetRtmpConnectMessage(char *rtmpMessgae)
int SetRtmpConnectMessage(unsigned char *data)
{
#if 0
    unsigned char * rtmpmessage = rtmpMessgae;

    int i;
    unsigned char data[6];
    int result;
    for (i=0; i<6; i++) {
        sscanf(rtmpmessage+i*2,"%02X",&result);
        data[i] = result & 0xFF;
    }

    printf("get rtmp ip: %d %d %d %d %d %d \n",data[0],data[1],data[2],data[3],data[4],data[5]);

    if((data[0]==0x00) && (data[1]==0x00) && (data[2]==0x00) && (data[3]==0x00))
    {
        Send_Log("get rtmp server ip is 0.0.0.0",0x0301);
        return -1;
    }
#else
	
    //unsigned char *data = rtmpMessgae;
    printf("get rtmp ip: %d %d %d %d %d %d \n",data[0],data[1],data[2],data[3],data[4],data[5]);
    if((data[0]==0x00) && (data[1]==0x00) && (data[2]==0x00) && (data[3]==0x00))
    {
        Send_Log("get rtmp server ip is 0.0.0.0",0x0301);
	printf("get rtmp ip is 000000 \n");
        return -1;
    }
#endif

    unsigned short port = *(unsigned short *)(data+4);
    char url[60];
    memset(url,0,60);
    sprintf(url,"rtmp://%d.%d.%d.%d:1935/demo/%d",data[3],data[2],data[1],data[0],platform_global_config.cid);
    strcpy(platform_global_config.rtmp_url,url);
  
    return 0;
}

int D_StartConnectToServer(char aMode,RTMPMetaData aMetadata)
{
	if(s_start_cloud_flag == 0)
		return -1;
	int i=0;
	if(aMode == 0x02)
		LY_PublicLiveFlag = 1;

	unsigned char ServerConnectInfo[10]={0};
	printf("===== amode ==== %d\n",aMode);
	unsigned char ret = ConnectToServer(aMode, ServerConnectInfo);
	printf("ConnectToServer ret === %x , info: %d %d %d %d %d %d\n",ret,ServerConnectInfo[0],ServerConnectInfo[1],ServerConnectInfo[2],ServerConnectInfo[3],ServerConnectInfo[4],ServerConnectInfo[5]);
	//if(ret != 0)
	//	return -1;

	int nRet =  SetRtmpConnectMessage(ServerConnectInfo);
	if(nRet == -1)
		goto failed;

	if(LY_PublicLiveFlag)
    	{
        	for(i=0;i<10;i++)
       		{
                	nRet = D_HttpPostRTMPURL(aMode);
                	if(nRet == 0)
                        	break;
                	else
                        	usleep(500);
        	}

		if(nRet != 0)
        		goto failed;
    	}

	nRet = D_StartRtmpServer(aMetadata);
	if(nRet == 0)
		return 0;

failed:
	D_Disconnect();
	return -1;
}

int  D_Disconnect()
{
	if(LY_PublicLiveFlag)
		D_HttpRemoveRTMPURL();	

	LY_PublicLiveFlag = 0;
	D_StopRtmpServer();
	return Disconnect();
}


int http_post_file(char* ip,int port,int cid, int timestamp,int is_recording,char* image_buffer, long image_size)
{
    CURL *curl = NULL;
    CURLcode res;
    
    struct curl_httppost *post=NULL;
    struct curl_httppost *last=NULL;
    
    //http_msg("======http_post_file start=========");
    if(image_buffer == NULL || ip == NULL)
    {
        //http_msg("image_buffer == NULL || ip == NULL");
        Send_Log("image_buffer == NULL || ip == NULL",0x0301);
	return -1;
    }
    
    char hashID[50];
    memset(hashID,0,50);
    GetDwordHash(cid,hashID);
    char hash[50];
    memset(hash,0,50);
    int i;
    for(i=0;i<8;i++)
    {
        sprintf(hash+i*2,"%02X",(unsigned char )hashID[i]);
    }
//    printf("hashid :%s\n",hash);
    
    char post_url[500];
    memset(post_url,0,sizeof(post_url));
    sprintf(post_url,"http://%s:%d/API/cameras/%s/images/upload",ip,port,hash);
   
    //printf("post pic:%s\n",post_url);
 
    char timestamp_str[30];
    memset(timestamp_str,0,sizeof(timestamp_str));
    sprintf(timestamp_str,"%d",timestamp);
    
    char is_recording_str[10];
    memset(is_recording_str,0,sizeof(is_recording_str));
    if(is_recording == 1)
        sprintf(is_recording_str,"1");
    else
        sprintf(is_recording_str,"0");
    
    char filename[200];
    memset(filename,0,sizeof(filename));
    sprintf(filename,"%d_%d.jpg",cid,timestamp);
    
    /* Add simple file section */
    
    if(curl_formadd(&post, &last, CURLFORM_COPYNAME, "is_recording",CURLFORM_PTRCONTENTS,is_recording_str,CURLFORM_CONTENTSLENGTH,strlen(is_recording_str), CURLFORM_END) != 0)
    {
        //http_msg("curl_formadd is_recording error");
	Send_Log("curl_formadd is_recording error",0x0301);
        curl_formfree(post);
        return -1;
    }
    
    if(curl_formadd(&post, &last, CURLFORM_COPYNAME, "timestamp",CURLFORM_PTRCONTENTS,timestamp_str,CURLFORM_CONTENTSLENGTH,strlen(timestamp_str), CURLFORM_END) != 0)
    {
        //http_msg("curl_formadd timestamp error");
	Send_Log("curl_formadd timestamp error",0x0301);
        curl_formfree(post);
        return -1;
    }
    
    if( curl_formadd(&post, &last, CURLFORM_COPYNAME, "pic",CURLFORM_BUFFER, filename,CURLFORM_BUFFERPTR,image_buffer,CURLFORM_BUFFERLENGTH,image_size, CURLFORM_END) != 0)
    {
        //http_msg("curl_formadd pic error");
	Send_Log("curl_formadd pic error",0x0301);
        curl_formfree(post);
        return -1;
    }
    
    curl = curl_easy_init();
    if(curl == NULL)
    {
        //http_msg("curl_easy_init() error");
	Send_Log("curl_easy_init() error",0x0301);
        curl_formfree(post);
        return -1;
    }
    
    curl_easy_setopt(curl, CURLOPT_HEADER, 0);
    curl_easy_setopt(curl, CURLOPT_URL, post_url); /*Set URL*/
    curl_easy_setopt(curl, CURLOPT_HTTPPOST, post);
    curl_easy_setopt(curl, CURLOPT_TIMEOUT, platform_global_config.web_server_timeout);
    
    res = curl_easy_perform(curl);
    if(res != CURLE_OK)
    {
        //http_msg("curl_easy_perform[%d] error", res);
        char err[50]={0};
	sprintf(err,"curl_easy_perform:%d,size:%d error",res,image_size);
	Send_Log((const char *)err,0x0301);
        curl_easy_cleanup(curl);
        curl_formfree(post);
        return -1;
    }
    
    //http_msg("http post success:filename:%s,ip:%s,port:%d,image_size:%d,is_recording:%d",filename,ip,port,image_size,is_recording);
    curl_easy_cleanup(curl);
    curl_formfree(post);
    return 0;
}
    
int  D_HttpPostPicture(int timestamp,char* image_buffer, long image_size, int is_recording_flag)
{
    if(is_recording_flag)
    {
	int ret=-1,i=0;
	char server_ip[50]={0};
	for(i=0; i<5; i++)
	{
    		ret =  http_post_file(server_ip,platform_global_config.web_server_port,platform_global_config.cid,timestamp, is_recording_flag,image_buffer,image_size);
    		if(ret == 0)
			break;
		else
			sleep(1);
	}
	return ret;
    }
    else
    {
    	return http_post_file(platform_global_config.web_server_ip,platform_global_config.web_server_port,platform_global_config.cid,timestamp, is_recording_flag,image_buffer,image_size);
    }
}

int httppost(char* ip,int port,char *hashID,char *rtmpUrl,int isremove)
{
    CURL *curl = NULL;
    CURLcode res;
    
    struct curl_httppost *post=NULL;
    struct curl_httppost *last=NULL;
    
    if( ip == NULL)
    {
        Send_Log("httppost ip = null",0x0301);
        return -1;
    }
    
    char post_url[500];
    memset(post_url,0,sizeof(post_url));
    if (isremove == 1)
        sprintf(post_url,"http://%s:%d/API/rtmp/%s/addr/remove",ip,port,hashID);
    else
        sprintf(post_url,"http://%s:%d/API/rtmp/addr",ip,port);
    
    /* Add simple file section */
    
    //printf("======param ========= :%s %s %d %s %d\n",post_url,hashID,strlen(hashID),rtmpUrl,strlen(rtmpUrl));
    
    if (isremove == 0)
    {
        if(curl_formadd(&post, &last, CURLFORM_COPYNAME, "hash_cid",CURLFORM_PTRCONTENTS,hashID,CURLFORM_CONTENTSLENGTH,strlen(hashID), CURLFORM_END) != 0)
        {
            Send_Log("curl_formadd hash_cid error\n",0x0301);
            curl_formfree(post);
            return -1;
        }
        
        if(curl_formadd(&post, &last, CURLFORM_COPYNAME, "addr",CURLFORM_PTRCONTENTS,rtmpUrl,CURLFORM_CONTENTSLENGTH,strlen(rtmpUrl), CURLFORM_END) != 0)
        {
            Send_Log("curl_formadd addr error\n",0x0301);
            curl_formfree(post);
            return -1;
        }
    }
    
    
    curl = curl_easy_init();
    if(curl == NULL)
    {
        Send_Log("curl_easy_init() error\n",0x0301);
        curl_formfree(post);
        return -1;
    }
    
    curl_easy_setopt(curl, CURLOPT_HEADER, 0);
    curl_easy_setopt(curl, CURLOPT_URL, post_url); /*Set URL*/
    curl_easy_setopt(curl, CURLOPT_HTTPPOST, post);
    curl_easy_setopt(curl, CURLOPT_TIMEOUT, platform_global_config.web_server_timeout);
    
    char err[62]={0};
    res = curl_easy_perform(curl);
    if(res != CURLE_OK)
    {
	memset(err,0,62);
	sprintf(err,"post url curl_easy_perform:%d,err",res);
	Send_Log((const char *)err,0x0301);
        curl_easy_cleanup(curl);
        curl_formfree(post);
        return -1;
    }
    
    memset(err,0,62);
    sprintf(err,"post url id:%s",hashID);
    Send_Log((const char *)err,0x0301);
    //printf("http post success:ip:%s,port:%d,hashID:%s,url:%s\n",ip,port,hashID,rtmpUrl);
    curl_easy_cleanup(curl);
    curl_formfree(post);
    return 0;
}
    
int  D_HttpPostRTMPURL(char aMode)
{
    char hashID[50];
    memset(hashID,0,50);
    GetDwordHash(platform_global_config.cid,hashID);
    char hash[50];
    memset(hash,0,50);
    int i,nRet;
    for(i=0;i<8;i++)
    {
        sprintf(hash+i*2,"%02X",(unsigned char )hashID[i]);
    }
    if(aMode == 0x02)
    {
    	char url[60];
    	memset(url,0,60);
    	sprintf(url,"rtmp://rtmp.public.topvdn.cn:1935/demo/%d",platform_global_config.cid);
    	nRet = httppost(platform_global_config.web_server_ip,platform_global_config.web_server_port,hash,url,0);
    }
    else
    	nRet = httppost(platform_global_config.web_server_ip,platform_global_config.web_server_port,hash,platform_global_config.rtmp_url,0);
    
    //printf("SDK:D_HttpPostRTMPURL httppost return:%d\n",nRet);

    return nRet;
}

int  D_HttpRemoveRTMPURL()
{
    char hashID[50];
    memset(hashID,0,50);
    GetDwordHash(platform_global_config.cid,hashID);
    char hash[50];
    memset(hash,0,50);
    int i;
    for(i=0;i<8;i++)
    {
        sprintf(hash+i*2,"%02X",(unsigned char )hashID[i]);
    }
    int nRet = httppost(platform_global_config.web_server_ip,platform_global_config.web_server_port,hash,platform_global_config.rtmp_url,1);
    //cmsprintf("SDK:D_HttpRemoveRTMPURL  httppost return:%d\n",nRet);
    return nRet;
}


int  D_SetRtmpConnectMessage(char *rtmpMessgae,char aMode)
{
    unsigned char * rtmpmessage = rtmpMessgae;
    
    int i;
    unsigned char data[6];
    int result;
    for (i=0; i<6; i++) {
        sscanf(rtmpmessage+i*2,"%02X",&result);
        data[i] = result & 0xFF;
    }
   
    Send_Log(data,0x0301);
#if  1 

    if(retry_count > 10)
	return -1;

    if(platform_global_config.cid == 0)
    {
	printf("D_SetRtmpConnectMessage cid = %d\n",platform_global_config.cid);
	retry_count++;
	D_Disconnect();
	sleep(2);
	//D_StartConnectToServer(aMode);
        return 0;
    }

    if((data[0]==0x00) && (data[1]==0x00) && (data[2]==0x00) && (data[3]==0x00))
    {
	Send_Log("get rtmp server ip is 0.0.0.0",0x0301);
	retry_count++;
	D_Disconnect();
	sleep(5);
	//D_StartConnectToServer(aMode);	
	return 0;
    }
#endif
    unsigned int ip = *(unsigned int *)rtmpmessage;
    char strIP[16];
    memset(strIP,0,16);
    //cmsprintf("....:%d.%d.%d.%d \n",data[3],data[2],data[1],data[0]);
    unsigned short port = *(unsigned short *)(data+4);
    
    //cmsprintf("strIP:%s,  port:%d \n",strIP,port);
    
    char url[60];
    memset(url,0,60);
//    sprintf(url,"rtmp://120.24.88.92/demo/%d",1003145);
//    sprintf(url,"rtmp://rtmp.public.topvdn.cn:1935/demo/%d",platform_global_config.cid);
//    sprintf(url,"rtmp://120.24.88.92:1935/demo/%d",platform_global_config.cid);
    sprintf(url,"rtmp://%d.%d.%d.%d:1935/demo/%d",data[3],data[2],data[1],data[0],platform_global_config.cid);
//    global_cofig.rtmp_open_flag = 1;
    strcpy(platform_global_config.rtmp_url,url);
   
    if(LY_PublicLiveFlag)
    {
        for(i=0;i<10;i++)
        {
                int ret = D_HttpPostRTMPURL(aMode);
                if(ret == 0)
                        return 1;
                else
                        usleep(500);
        }

        return -1;
    }
    else
        return 1;

}

int http_post_message(char* ip,int port,char *token, char* msg_buffer, long msg_size)
{
    CURL *curl = NULL;
    CURLcode res;

    struct curl_httppost *post=NULL;
    struct curl_httppost *last=NULL;
    if(token ==NULL || msg_buffer == NULL || ip == NULL)
    {
        Send_Log("post_msg token or msg or ip == NULL",0x0301);
	return -1;
    }
    
    char post_url[500];
    memset(post_url,0,sizeof(post_url));
    //sprintf(post_url,"http://%s:%d/API/cameras/%s/images/upload",ip,port,hash);
    sprintf(post_url,"http://%s:%d/API/message/cameras/touser",ip,port);
    //http://121.41.118.167:8006/API/message/cameras/touser   
    printf("post msg:%s\n",post_url);
 
    /* Add simple file section */

/* 
    //if( curl_formadd(&post, &last, CURLFORM_COPYNAME, "msg",CURLFORM_BUFFER, filename,CURLFORM_BUFFERPTR,msg_buffer,CURLFORM_BUFFERLENGTH,msg_size, CURLFORM_END) != 0)
    if( curl_formadd(&post, &last, CURLFORM_COPYNAME, "msg",CURLFORM_BUFFERPTR,msg_buffer,CURLFORM_BUFFERLENGTH,msg_size, CURLFORM_END) != 0)
    {
	Send_Log("curl_formadd msg error",0x0301);
        curl_formfree(post);
        return -1;
    }
*/  
    
    curl = curl_easy_init();
    if(curl == NULL)
    {
	Send_Log("curl_msg_init() error",0x0301);
        curl_formfree(post);
        return -1;
    }

    /* set http header */
    struct  crul_slist*   headers = NULL;//init to NULL
    char header_str[100]={0};
    sprintf(header_str,"X-Camera-Token:%s",token);
    printf("post header :%s\n",header_str);

    /* Remove a header curl would otherwise add by itself */ 
    headers = curl_slist_append(headers, "Accept:");
 
    /* Add a custom header */ 
    headers = curl_slist_append(headers,"Content-Type: application/json; charset=utf-8");
    headers = curl_slist_append(headers,header_str);
    //headers = curl_slist_append(headers,"X-Camera-Token:9D4E0F00F9D1F855FFFFFFD7AB2457F3C2D3A6F48E4BB824FE2B635F");
    //headers = curl_slist_append(headers,"Hey-server-hey:how are you?");
    //headers = curl_slist_append(headers,"X-silly-content:yes");
    curl_easy_setopt(curl,CURLOPT_HTTPHEADER,headers);

    curl_easy_setopt(curl,CURLOPT_POSTFIELDS,msg_buffer);
    curl_easy_setopt(curl,CURLOPT_POSTFIELDSIZE,msg_size);
   
    curl_easy_setopt(curl, CURLOPT_POST,1); 
    curl_easy_setopt(curl, CURLOPT_HEADER, 0);
    curl_easy_setopt(curl, CURLOPT_URL, post_url); /*Set URL*/
    curl_easy_setopt(curl, CURLOPT_HTTPPOST, post);
    curl_easy_setopt(curl, CURLOPT_TIMEOUT, platform_global_config.web_server_timeout);
    
    res = curl_easy_perform(curl);
    if(res != CURLE_OK)
    {
        char err[50]={0};
	sprintf(err,"curl_msg_perform:%d,size:%d error",res,msg_size);
	Send_Log((const char *)err,0x0301);
        curl_easy_cleanup(curl);
        curl_formfree(post);
        /* free the custom headers */ 
        curl_slist_free_all(headers);
        return -1;
    }
    
    curl_easy_cleanup(curl);
    curl_formfree(post);
    /* free the custom headers */ 
    curl_slist_free_all(headers);
    return 0;
}
    
const char base[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
static char find_pos(char ch)
{
    char *ptr = (char*)strrchr(base, ch);//the last position (the only) in base[]
    return (ptr - base);
}

char *base64_decode(const char *data, int data_len)
{
    int equal_count = 0;
    char *ret = NULL;
    char *f = NULL;
    int tmp = 0;
    int temp = 0;
    char need[3];
    int prepare = 0;
    int i = 0;
    int ret_len = (data_len / 4) * 3;
    if (*(data + data_len - 1) == '=')
    {
        equal_count += 1;
    }
    if (*(data + data_len - 2) == '=')
    {
        equal_count += 1;
    }
    if (*(data + data_len - 3) == '=')
    {//seems impossible
        equal_count += 1;
    }
    switch (equal_count)
    {
        case 0:
            ret_len += 4;//3 + 1 [1 for NULL]
            break;
        case 1:
            ret_len += 4;//Ceil((6*3)/8)+1
            break;
        case 2:
            ret_len += 3;//Ceil((6*2)/8)+1
            break;
        case 3:
            ret_len += 2;//Ceil((6*1)/8)+1
            break;
    }
    ret = (char *)malloc(ret_len);
    if (ret == NULL)
    {
        printf("base64_decode No enough memory.\n");
        return NULL;
    }
    memset(ret, 0, ret_len);
    f = ret;
    while (tmp < (data_len - equal_count))
    {
        temp = 0;
        prepare = 0;
        memset(need, 0, 4);
        while (temp < 4)
        {
            if (tmp >= (data_len - equal_count))
            {
                break;
            }
            prepare = (prepare << 6) | (find_pos(data[tmp]));
            temp++;
            tmp++;
        }
        prepare = prepare << ((4-temp) * 6);
        for (i=0; i<3 ;i++ )
        {
            if (i == temp)
            {
                break;
            }
            *f = (char)((prepare>>((2-i)*8)) & 0xFF);
            f++;
        }
    }
    *f = '\0';
    return ret;
}

int getMessageJson(int aCid, char *aMessage, int is_callServer, char * json, unsigned int json_size)
{
    char *out = NULL;
    int out_len = 0;
    char hashID[50];
    memset(hashID,0,50);
    GetDwordHash(aCid,hashID);
    char hash[50];
    memset(hash,0,50);
    int i;
    for(i=0;i<8;i++)
    {
        sprintf(hash+i*2,"%02X",(unsigned char )hashID[i]);
    }
    printf("hashid :%s, len:%d\n",hash,strlen(hash));

    char is_recording_str[10] = {0};
    if(is_callServer == 1)
        sprintf(is_recording_str,"1");
    else
        sprintf(is_recording_str,"0");

    /*json root*/
    cJSON * root=cJSON_CreateObject();
    /*json of timestamp.*/
    //cJSON_AddItemToObject(root, "report", json_report);
    cJSON_AddStringToObject(root, "from", hash);
    cJSON_AddStringToObject(root, "msg", aMessage);
    cJSON_AddStringToObject(root, "callback", is_recording_str);

    /*json output.*/
    out=cJSON_Print(root);
    out_len=strlen(out);
    if (json != NULL && json_size >= out_len) {
        memcpy(json, out, out_len);
        cJSON_Delete(root);
        free(out);
	out = NULL;
        return 0;
    }
    
    cJSON_Delete(root);
    free(out);
    out = NULL;
    return -1;
}

int   D_PushMessage(const char *aMessage, unsigned long aMessageLen, int is_callServer)
{
    int ret = -1;
    printf("msg= %d %d %d %d %d %d, len=%d\n",aMessage[0],aMessage[1],aMessage[2],aMessage[3],aMessage[4],aMessage[5],aMessageLen);
    char token[100] = {0};
    int token_len = D_GetDeviceToken(token);
    printf("token");
    if(token_len == -1)
	return -1;

    char *message = base64_decode(aMessage, aMessageLen);
    //printf("decode message === %s, len == %d\n",message,strlen(message));
    if(message == NULL)
    {
	Send_Log("push msg base64_decode null",0x0301);
	return -1;
    }
    char msg_json[500]={0};
    ret = getMessageJson(platform_global_config.cid, message, is_callServer, msg_json, (unsigned int)sizeof(msg_json));
    if(ret != 0)
	return ret;

    printf("msg json:%s, len:%d\n",msg_json,strlen(msg_json));

    ret = http_post_message("121.41.118.167", 8006, token, msg_json, strlen(msg_json));
    
    return ret;
}
